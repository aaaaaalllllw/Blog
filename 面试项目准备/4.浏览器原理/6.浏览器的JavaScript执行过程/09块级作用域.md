# 09|块级作用域：var缺陷以及为什么要引入let和const?


**正是由于JavaScript存在变量提升这种特性，从而导致很多与直觉不符合的代码，这也是JavaScript的一个重要设计缺陷**

分析为什么——介绍如何通过**开药房**——介绍如何通过**块级作用域并配合let和const关键字**来修复这种缺陷。


## 作用域(scope)

为什么JavaScript中会存在变量提升这个特性，其他语言似乎没有这个特性，作用域讲起。


**作用域是指在程序中定义变量的区域，该位置决定了变量的声明周期。通俗地理解，作用域就是变量与可访问范围，即作用域控制得变量和函数的可见性和生命周期**


在ES6之前，ES的作用域只有两种：全局作用域和函数作用域


**全局作用域**中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。


**函数作用域**就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。


现在支持**块级作用域**。块级作用域就是一对大括号包括的一段代码，比如函数、判断语句、循环语句
甚至单独的一个{}都可以看坐一个块级作用域。

```js
//if块
if(1){}

//while块
while(1){}

//函数块
function foo(){}

//for 循环块
for(let i=0;i<100;i++){}

//单独一个快
{}
```


## 变量提升所带来的问题

### 1.变量容易在不被察觉的情况下被覆盖掉

由于变量提升作用，使用JavaScript来编写和其他语言相同逻辑的代码，都可能会导致不一样的执行结果。那为什么会出现这种情况？主要以下两种原因？

```js
var myname="极客时间"

function showName(){
    console.log(myname)//undefined
    if(0){
        var myname="极客邦"//块级作用域
    }
    console.log(myname)//undefined
}

showName()
```

当刚执行到showName函数调用时，执行上文和调用栈的状态是怎样的状态？

![这是图片](./img/20.png)


showName函数的执行上下文创建后，JavaScript引擎便开始执行showName函数内部的代码，首先执行

```js
console.log(myname)
```
执行这段代码需要使用变量myname，结合上面的调用栈状态图，可以两个myname变量；一个在全局执行上下文中，其值是“极客时间”；另外一个在showName函数的执行上下文中，其值是undefined。。那么应该使用哪个？

“当然**先使用函数执行上下文里面的变量**”的确是这样，这是因为在函数执行过程中，JavaScript会有优先从当前的执行上下文查找变量，由于变量提升，当前的执行上下文就包含变量myname，而值是undefined，所以获取到myname的值就是undefined。



### 2.本应销毁的变量没有被销毁

在创建执行上下文阶段，变量 i 就已经被提升了，var变量提升。

```js
function foo(){
    for(var i=0;i<7;i++){
    }
    console.log(i)
}
foo()
```
如果使用C语言或者其他部分的实现类似代码，i的值并未被销毁，所以最后打印出来的是7。

这同样也是由变量提升而导致的，在创建执行上下文阶段，变量i就已经提升了，所以当for循环结束之后，变量i并没有被销毁。

## ES6是如何解决变量提升带来的缺陷

**ES6引入let和const关键字**，从而使JavaScript其他语言一样拥有块级作用域

```js
let x=5
const y=6
x=7
y=9//报错，const声明变量不可修改
```
## 组合问题-力扣 77

给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

示例: 输入: n = 4, k = 2 输出: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ]

## 思路

回溯法解决的问题可以抽象为树形结构(N 叉树),用树形结构来解决回溯容易多了。
![这是图片](./1.png)

## 回溯三部曲

- 递归函数的返回值以及参数

path//存放单一路径结果

result//存放全部结果

还需要一个 startIndex 防止重叠,记录深度递归开始位置

- 终止条件
  什么时候到达所谓的叶子节点了呢？

path 这个数组的大小如果达到 k，说明我们找到了一个子集大小为 k 的组合了，在图中 path 存的就是根节点到叶子节点的路径。

```js
if (path.length == k) {
  result.push(path);
  return;
}
```

- 单层回溯逻辑

```js
/**
 * @param {number} n
 * @param {number} k
 * @return {number[][]}
 */
var combine = function (n, k) {
  let path = [],
    result = [];
  function backtracing(n, k, startIndex) {
    if (path.length == k) {
      result.push([...path]);
      return;
    }
    for (let i = startIndex; i <= n; i++) {
      path.push(i);
      backtracing(n, k, i + 1);
      path.pop();
    }
  }
  backtracing(n, k, 1);
  return result;
};
s;
```

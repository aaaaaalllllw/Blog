## 1049.最后一块石头的重要||

有一堆石头，每块石头的重量都是正整数。

每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

如果 x == y，那么两块石头都会被完全粉碎；

如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。

最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。

示例:

- 输入:[2,7,4,1,8,1]

- 输出:1

解释

- 组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
- 组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
- 组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
- 组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。

## 思路

本题重量 stones[i],物品的价值为 stones[i]
对应着物品重量 weight[i],物品价值 value[i]

动规五部曲

1. 确定 dp 数组以及下标的含义
   j 表示容易，dp[j]能背起最重的石头
2. 确定递推公式
   01 背包的递推公式:dp[j]=Math.max(dp[j],dp[j-weight[i]]value[i])
   本题就是 dp[j]=Math.max(dp[j],dp[j-stones[i]+stones[i]])

3. dp 数组如何初始化
   而我们要求的 target 其实只是最大重量的一半

4. 确定遍历顺序
   外层正序遍历石头个数，内层倒序遍历 target

5. 举例推导数组
   举例，输入：[2,4,1,1]，此时 target = (2 + 4 + 1 + 1)/2 = 4 ，dp 数组状态图如下：
   ![这是图片](./1.jpg)
   最后 dp[target]里是容量为 target 的背包所能背的最大重量。

那么分成两堆石头，一堆石头的总重量是 dp[target]，另一堆就是 sum - dp[target]。

在计算 target 的时候，target = sum / 2 因为是向下取整，所以 sum - dp[target] 一定是大于等于 dp[target]的。

**那么相撞之后剩下的最小石头重量就是 (sum - dp[target]) - dp[target]**

## 代码

```js

```

尽量让石头分成重量相同的两堆
背包背的是全部重量的/2 的向下取整的一般，减去两个相同的剩下就是多余的石头
